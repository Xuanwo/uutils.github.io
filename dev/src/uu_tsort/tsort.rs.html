<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/uu/tsort/src/tsort.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>tsort.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../uu_tsort/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
</pre><pre class="rust"><code><span class="comment">//  * This file is part of the uutils coreutils package.
//  *
//  * (c) Ben Eggers &lt;ben.eggers36@gmail.com&gt;
//  * (c) Akira Hayakawa &lt;ruby.wktk@gmail.com&gt;
//  *
//  * For the full copyright and license information, please view the LICENSE
//  * file that was distributed with this source code.
</span><span class="kw">use </span>clap::{crate_version, Arg, Command};
<span class="kw">use </span>std::collections::{HashMap, HashSet};
<span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::{stdin, BufRead, BufReader, Read};
<span class="kw">use </span>std::path::Path;
<span class="kw">use </span>uucore::display::Quotable;
<span class="kw">use </span>uucore::error::{FromIo, UResult, USimpleError};
<span class="kw">use </span>uucore::format_usage;

<span class="kw">static </span>ABOUT: <span class="kw-2">&amp;</span>str = <span class="string">&quot;Topological sort the strings in FILE.
Strings are defined as any sequence of tokens separated by whitespace (tab, space, or newline).
If FILE is not passed in, stdin is used instead.&quot;</span>;
<span class="kw">static </span>USAGE: <span class="kw-2">&amp;</span>str = <span class="string">&quot;{} [OPTIONS] FILE&quot;</span>;

<span class="kw">mod </span>options {
    <span class="kw">pub const </span>FILE: <span class="kw-2">&amp;</span>str = <span class="string">&quot;file&quot;</span>;
}

<span class="attribute">#[uucore::main]
</span><span class="kw">pub fn </span>uumain(args: <span class="kw">impl </span>uucore::Args) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>args = args.collect_lossy();

    <span class="kw">let </span>matches = uu_app().try_get_matches_from(args)<span class="question-mark">?</span>;

    <span class="kw">let </span>input = matches
        .get_one::&lt;String&gt;(options::FILE)
        .expect(<span class="string">&quot;Value is required by clap&quot;</span>);

    <span class="kw">let </span><span class="kw-2">mut </span>stdin_buf;
    <span class="kw">let </span><span class="kw-2">mut </span>file_buf;
    <span class="kw">let </span><span class="kw-2">mut </span>reader = BufReader::new(<span class="kw">if </span>input == <span class="string">&quot;-&quot; </span>{
        stdin_buf = stdin();
        <span class="kw-2">&amp;mut </span>stdin_buf <span class="kw">as </span><span class="kw-2">&amp;mut </span><span class="kw">dyn </span>Read
    } <span class="kw">else </span>{
        file_buf = File::open(Path::new(<span class="kw-2">&amp;</span>input)).map_err_context(|| input.to_string())<span class="question-mark">?</span>;
        <span class="kw-2">&amp;mut </span>file_buf <span class="kw">as </span><span class="kw-2">&amp;mut </span><span class="kw">dyn </span>Read
    });

    <span class="kw">let </span><span class="kw-2">mut </span>g = Graph::new();
    <span class="kw">loop </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>line = String::new();
        <span class="kw">match </span>reader.read_line(<span class="kw-2">&amp;mut </span>line) {
            <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; {
                <span class="kw">let </span>tokens: Vec&lt;String&gt; = line.split_whitespace().map(|s| s.to_owned()).collect();
                <span class="kw">if </span>tokens.is_empty() {
                    <span class="kw">break</span>;
                }
                <span class="kw">for </span>ab <span class="kw">in </span>tokens.chunks(<span class="number">2</span>) {
                    <span class="kw">match </span>ab.len() {
                        <span class="number">2 </span>=&gt; g.add_edge(<span class="kw-2">&amp;</span>ab[<span class="number">0</span>], <span class="kw-2">&amp;</span>ab[<span class="number">1</span>]),
                        <span class="kw">_ </span>=&gt; {
                            <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(
                                <span class="number">1</span>,
                                <span class="macro">format!</span>(
                                    <span class="string">&quot;{}: input contains an odd number of tokens&quot;</span>,
                                    input.maybe_quote()
                                ),
                            ))
                        }
                    }
                }
            }
            <span class="kw">_ </span>=&gt; <span class="kw">break</span>,
        }
    }

    g.run_tsort();

    <span class="kw">if </span>!g.is_acyclic() {
        <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(
            <span class="number">1</span>,
            <span class="macro">format!</span>(<span class="string">&quot;{}, input contains a loop:&quot;</span>, input),
        ));
    }

    <span class="kw">for </span>x <span class="kw">in </span><span class="kw-2">&amp;</span>g.result {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, x);
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">pub fn </span>uu_app() -&gt; Command {
    Command::new(uucore::util_name())
        .version(<span class="macro">crate_version!</span>())
        .override_usage(format_usage(USAGE))
        .about(ABOUT)
        .infer_long_args(<span class="bool-val">true</span>)
        .arg(
            Arg::new(options::FILE)
                .default_value(<span class="string">&quot;-&quot;</span>)
                .hide(<span class="bool-val">true</span>)
                .value_hint(clap::ValueHint::FilePath),
        )
}

<span class="comment">// We use String as a representation of node here
// but using integer may improve performance.
</span><span class="attribute">#[derive(Default)]
</span><span class="kw">struct </span>Graph {
    in_edges: HashMap&lt;String, HashSet&lt;String&gt;&gt;,
    out_edges: HashMap&lt;String, Vec&lt;String&gt;&gt;,
    result: Vec&lt;String&gt;,
}

<span class="kw">impl </span>Graph {
    <span class="kw">fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::default()
    }

    <span class="kw">fn </span>has_node(<span class="kw-2">&amp;</span><span class="self">self</span>, n: <span class="kw-2">&amp;</span>str) -&gt; bool {
        <span class="self">self</span>.in_edges.contains_key(n)
    }

    <span class="kw">fn </span>has_edge(<span class="kw-2">&amp;</span><span class="self">self</span>, from: <span class="kw-2">&amp;</span>str, to: <span class="kw-2">&amp;</span>str) -&gt; bool {
        <span class="self">self</span>.in_edges[to].contains(from)
    }

    <span class="kw">fn </span>init_node(<span class="kw-2">&amp;mut </span><span class="self">self</span>, n: <span class="kw-2">&amp;</span>str) {
        <span class="self">self</span>.in_edges.insert(n.to_string(), HashSet::new());
        <span class="self">self</span>.out_edges.insert(n.to_string(), <span class="macro">vec!</span>[]);
    }

    <span class="kw">fn </span>add_edge(<span class="kw-2">&amp;mut </span><span class="self">self</span>, from: <span class="kw-2">&amp;</span>str, to: <span class="kw-2">&amp;</span>str) {
        <span class="kw">if </span>!<span class="self">self</span>.has_node(to) {
            <span class="self">self</span>.init_node(to);
        }

        <span class="kw">if </span>!<span class="self">self</span>.has_node(from) {
            <span class="self">self</span>.init_node(from);
        }

        <span class="kw">if </span>from != to &amp;&amp; !<span class="self">self</span>.has_edge(from, to) {
            <span class="self">self</span>.in_edges.get_mut(to).unwrap().insert(from.to_string());
            <span class="self">self</span>.out_edges.get_mut(from).unwrap().push(to.to_string());
        }
    }

    <span class="comment">// Kahn&#39;s algorithm
    // O(|V|+|E|)
    </span><span class="kw">fn </span>run_tsort(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw">let </span><span class="kw-2">mut </span>start_nodes = <span class="macro">vec!</span>[];
        <span class="kw">for </span>(n, edges) <span class="kw">in </span><span class="kw-2">&amp;</span><span class="self">self</span>.in_edges {
            <span class="kw">if </span>edges.is_empty() {
                start_nodes.push(n.clone());
            }
        }

        <span class="kw">while </span>!start_nodes.is_empty() {
            <span class="kw">let </span>n = start_nodes.remove(<span class="number">0</span>);

            <span class="self">self</span>.result.push(n.clone());

            <span class="kw">let </span>n_out_edges = <span class="self">self</span>.out_edges.get_mut(<span class="kw-2">&amp;</span>n).unwrap();
            <span class="kw">for </span>m <span class="kw">in </span>n_out_edges.iter() {
                <span class="kw">let </span>m_in_edges = <span class="self">self</span>.in_edges.get_mut(m).unwrap();
                m_in_edges.remove(<span class="kw-2">&amp;</span>n);

                <span class="comment">// If m doesn&#39;t have other in-coming edges add it to start_nodes
                </span><span class="kw">if </span>m_in_edges.is_empty() {
                    start_nodes.push(m.clone());
                }
            }
            n_out_edges.clear();
        }
    }

    <span class="kw">fn </span>is_acyclic(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="kw">for </span>edges <span class="kw">in </span><span class="self">self</span>.out_edges.values() {
            <span class="kw">if </span>!edges.is_empty() {
                <span class="kw">return </span><span class="bool-val">false</span>;
            }
        }
        <span class="bool-val">true
    </span>}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="uu_tsort" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>