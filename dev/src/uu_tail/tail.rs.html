<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/uu/tail/src/tail.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>tail.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../uu_tail/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
</pre><pre class="rust"><code><span class="comment">//  * This file is part of the uutils coreutils package.
//  *
//  * (c) Morten Olsen Lysgaard &lt;morten@lysgaard.no&gt;
//  * (c) Alexander Batischev &lt;eual.jp@gmail.com&gt;
//  * (c) Thomas Queiroz &lt;thomasqueirozb@gmail.com&gt;
//  *
//  * For the full copyright and license information, please view the LICENSE
//  * file that was distributed with this source code.

// spell-checker:ignore (ToDO) seekable seek&#39;d tail&#39;ing ringbuffer ringbuf unwatch Uncategorized filehandle Signum
// spell-checker:ignore (libs) kqueue
// spell-checker:ignore (acronyms)
// spell-checker:ignore (env/flags)
// spell-checker:ignore (jargon) tailable untailable stdlib
// spell-checker:ignore (names)
// spell-checker:ignore (shell/tools)
// spell-checker:ignore (misc)

</span><span class="kw">pub mod </span>args;
<span class="kw">pub mod </span>chunks;
<span class="kw">mod </span>follow;
<span class="kw">mod </span>parse;
<span class="kw">mod </span>paths;
<span class="kw">mod </span>platform;
<span class="kw">pub mod </span>text;

<span class="kw">pub use </span>args::uu_app;
<span class="kw">use </span>args::{parse_args, FilterMode, Settings, Signum};
<span class="kw">use </span>chunks::ReverseChunks;
<span class="kw">use </span>follow::Observer;
<span class="kw">use </span>paths::{FileExtTail, HeaderPrinter, Input, InputKind, MetadataExtTail};
<span class="kw">use </span>same_file::Handle;
<span class="kw">use </span>std::cmp::Ordering;
<span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::{<span class="self">self</span>, stdin, stdout, BufRead, BufReader, BufWriter, Read, Seek, SeekFrom, Write};
<span class="kw">use </span>std::path::{Path, PathBuf};
<span class="kw">use </span>uucore::display::Quotable;
<span class="kw">use </span>uucore::error::{get_exit_code, set_exit_code, FromIo, UError, UResult, USimpleError};
<span class="kw">use </span>uucore::{show, show_error};

<span class="attribute">#[uucore::main]
</span><span class="kw">pub fn </span>uumain(args: <span class="kw">impl </span>uucore::Args) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>settings = parse_args(args)<span class="question-mark">?</span>;

    settings.check_warnings();

    <span class="kw">match </span>settings.verify() {
        args::VerificationResult::CannotFollowStdinByName =&gt; {
            <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(
                <span class="number">1</span>,
                <span class="macro">format!</span>(<span class="string">&quot;cannot follow {} by name&quot;</span>, text::DASH.quote()),
            ))
        }
        <span class="comment">// Exit early if we do not output anything. Note, that this may break a pipe
        // when tail is on the receiving side.
        </span>args::VerificationResult::NoOutput =&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(()),
        args::VerificationResult::Ok =&gt; {}
    }

    uu_tail(<span class="kw-2">&amp;</span>settings)
}

<span class="kw">fn </span>uu_tail(settings: <span class="kw-2">&amp;</span>Settings) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>printer = HeaderPrinter::new(settings.verbose, <span class="bool-val">true</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>observer = Observer::from(settings);

    observer.start(settings)<span class="question-mark">?</span>;
    <span class="comment">// Do an initial tail print of each path&#39;s content.
    // Add `path` and `reader` to `files` map if `--follow` is selected.
    </span><span class="kw">for </span>input <span class="kw">in </span><span class="kw-2">&amp;</span>settings.inputs.clone() {
        <span class="kw">match </span>input.kind() {
            InputKind::File(path) <span class="kw">if </span><span class="macro">cfg!</span>(not(unix)) || path != <span class="kw-2">&amp;</span>PathBuf::from(text::DEV_STDIN) =&gt; {
                tail_file(settings, <span class="kw-2">&amp;mut </span>printer, input, path, <span class="kw-2">&amp;mut </span>observer, <span class="number">0</span>)<span class="question-mark">?</span>;
            }
            <span class="comment">// File points to /dev/stdin here
            </span>InputKind::File(<span class="kw">_</span>) | InputKind::Stdin =&gt; {
                tail_stdin(settings, <span class="kw-2">&amp;mut </span>printer, input, <span class="kw-2">&amp;mut </span>observer)<span class="question-mark">?</span>;
            }
        }
    }

    <span class="kw">if </span>settings.follow.is_some() {
        <span class="comment">/*
        POSIX specification regarding tail -f
        If the input file is a regular file or if the file operand specifies a FIFO, do not
        terminate after the last line of the input file has been copied, but read and copy
        further bytes from the input file when they become available. If no file operand is
        specified and standard input is a pipe or FIFO, the -f option shall be ignored. If
        the input file is not a FIFO, pipe, or regular file, it is unspecified whether or
        not the -f option shall be ignored.
        */
        </span><span class="kw">if </span>!settings.has_only_stdin() {
            follow::follow(observer, settings)<span class="question-mark">?</span>;
        }
    }

    <span class="kw">if </span>get_exit_code() &gt; <span class="number">0 </span>&amp;&amp; paths::stdin_is_bad_fd() {
        <span class="macro">show_error!</span>(<span class="string">&quot;-: {}&quot;</span>, text::BAD_FD);
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>tail_file(
    settings: <span class="kw-2">&amp;</span>Settings,
    header_printer: <span class="kw-2">&amp;mut </span>HeaderPrinter,
    input: <span class="kw-2">&amp;</span>Input,
    path: <span class="kw-2">&amp;</span>Path,
    observer: <span class="kw-2">&amp;mut </span>Observer,
    offset: u64,
) -&gt; UResult&lt;()&gt; {
    <span class="kw">if </span>!path.exists() {
        set_exit_code(<span class="number">1</span>);
        <span class="macro">show_error!</span>(
            <span class="string">&quot;cannot open &#39;{}&#39; for reading: {}&quot;</span>,
            input.display_name,
            text::NO_SUCH_FILE
        );
        observer.add_bad_path(path, input.display_name.as_str(), <span class="bool-val">false</span>)<span class="question-mark">?</span>;
    } <span class="kw">else if </span>path.is_dir() {
        set_exit_code(<span class="number">1</span>);

        header_printer.print_input(input);
        <span class="kw">let </span>err_msg = <span class="string">&quot;Is a directory&quot;</span>.to_string();

        <span class="macro">show_error!</span>(<span class="string">&quot;error reading &#39;{}&#39;: {}&quot;</span>, input.display_name, err_msg);
        <span class="kw">if </span>settings.follow.is_some() {
            <span class="kw">let </span>msg = <span class="kw">if </span>!settings.retry {
                <span class="string">&quot;; giving up on this name&quot;
            </span>} <span class="kw">else </span>{
                <span class="string">&quot;&quot;
            </span>};
            <span class="macro">show_error!</span>(
                <span class="string">&quot;{}: cannot follow end of this type of file{}&quot;</span>,
                input.display_name,
                msg
            );
        }
        <span class="kw">if </span>!(observer.follow_name_retry()) {
            <span class="comment">// skip directory if not retry
            </span><span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }
        observer.add_bad_path(path, input.display_name.as_str(), <span class="bool-val">false</span>)<span class="question-mark">?</span>;
    } <span class="kw">else if </span>input.is_tailable() {
        <span class="kw">let </span>metadata = path.metadata().ok();
        <span class="kw">match </span>File::open(path) {
            <span class="prelude-val">Ok</span>(<span class="kw-2">mut </span>file) =&gt; {
                header_printer.print_input(input);
                <span class="kw">let </span><span class="kw-2">mut </span>reader;
                <span class="kw">if </span>!settings.presume_input_pipe
                    &amp;&amp; file.is_seekable(<span class="kw">if </span>input.is_stdin() { offset } <span class="kw">else </span>{ <span class="number">0 </span>})
                    &amp;&amp; metadata.as_ref().unwrap().get_block_size() &gt; <span class="number">0
                </span>{
                    bounded_tail(<span class="kw-2">&amp;mut </span>file, settings);
                    reader = BufReader::new(file);
                } <span class="kw">else </span>{
                    reader = BufReader::new(file);
                    unbounded_tail(<span class="kw-2">&amp;mut </span>reader, settings)<span class="question-mark">?</span>;
                }
                observer.add_path(
                    path,
                    input.display_name.as_str(),
                    <span class="prelude-val">Some</span>(Box::new(reader)),
                    <span class="bool-val">true</span>,
                )<span class="question-mark">?</span>;
            }
            <span class="prelude-val">Err</span>(e) <span class="kw">if </span>e.kind() == std::io::ErrorKind::PermissionDenied =&gt; {
                observer.add_bad_path(path, input.display_name.as_str(), <span class="bool-val">false</span>)<span class="question-mark">?</span>;
                <span class="macro">show!</span>(e.map_err_context(|| {
                    <span class="macro">format!</span>(<span class="string">&quot;cannot open &#39;{}&#39; for reading&quot;</span>, input.display_name)
                }));
            }
            <span class="prelude-val">Err</span>(e) =&gt; {
                observer.add_bad_path(path, input.display_name.as_str(), <span class="bool-val">false</span>)<span class="question-mark">?</span>;
                <span class="kw">return </span><span class="prelude-val">Err</span>(e.map_err_context(|| {
                    <span class="macro">format!</span>(<span class="string">&quot;cannot open &#39;{}&#39; for reading&quot;</span>, input.display_name)
                }));
            }
        }
    } <span class="kw">else </span>{
        observer.add_bad_path(path, input.display_name.as_str(), <span class="bool-val">false</span>)<span class="question-mark">?</span>;
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>tail_stdin(
    settings: <span class="kw-2">&amp;</span>Settings,
    header_printer: <span class="kw-2">&amp;mut </span>HeaderPrinter,
    input: <span class="kw-2">&amp;</span>Input,
    observer: <span class="kw-2">&amp;mut </span>Observer,
) -&gt; UResult&lt;()&gt; {
    <span class="kw">match </span>input.resolve() {
        <span class="comment">// fifo
        </span><span class="prelude-val">Some</span>(path) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>stdin_offset = <span class="number">0</span>;
            <span class="kw">if </span><span class="macro">cfg!</span>(unix) {
                <span class="comment">// Save the current seek position/offset of a stdin redirected file.
                // This is needed to pass &quot;gnu/tests/tail-2/start-middle.sh&quot;
                </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(<span class="kw-2">mut </span>stdin_handle) = Handle::stdin() {
                    <span class="kw">if let </span><span class="prelude-val">Ok</span>(offset) = stdin_handle.as_file_mut().seek(SeekFrom::Current(<span class="number">0</span>)) {
                        stdin_offset = offset;
                    }
                }
            }
            tail_file(
                settings,
                header_printer,
                input,
                <span class="kw-2">&amp;</span>path,
                observer,
                stdin_offset,
            )<span class="question-mark">?</span>;
        }
        <span class="comment">// pipe
        </span><span class="prelude-val">None </span>=&gt; {
            header_printer.print_input(input);
            <span class="kw">if </span>!paths::stdin_is_bad_fd() {
                <span class="kw">let </span><span class="kw-2">mut </span>reader = BufReader::new(stdin());
                unbounded_tail(<span class="kw-2">&amp;mut </span>reader, settings)<span class="question-mark">?</span>;
                observer.add_stdin(input.display_name.as_str(), <span class="prelude-val">Some</span>(Box::new(reader)), <span class="bool-val">true</span>)<span class="question-mark">?</span>;
            } <span class="kw">else </span>{
                set_exit_code(<span class="number">1</span>);
                <span class="macro">show_error!</span>(
                    <span class="string">&quot;cannot fstat {}: {}&quot;</span>,
                    text::STDIN_HEADER.quote(),
                    text::BAD_FD
                );
                <span class="kw">if </span>settings.follow.is_some() {
                    <span class="macro">show_error!</span>(
                        <span class="string">&quot;error reading {}: {}&quot;</span>,
                        text::STDIN_HEADER.quote(),
                        text::BAD_FD
                    );
                }
            }
        }
    };

    <span class="prelude-val">Ok</span>(())
}

<span class="doccomment">/// Find the index after the given number of instances of a given byte.
///
/// This function reads through a given reader until `num_delimiters`
/// instances of `delimiter` have been seen, returning the index of
/// the byte immediately following that delimiter. If there are fewer
/// than `num_delimiters` instances of `delimiter`, this returns the
/// total number of bytes read from the `reader` until EOF.
///
/// # Errors
///
/// This function returns an error if there is an error during reading
/// from `reader`.
///
/// # Examples
///
/// Basic usage:
///
/// ```rust,ignore
/// use std::io::Cursor;
///
/// let mut reader = Cursor::new(&quot;a\nb\nc\nd\ne\n&quot;);
/// let i = forwards_thru_file(&amp;mut reader, 2, b&#39;\n&#39;).unwrap();
/// assert_eq!(i, 4);
/// ```
///
/// If `num_delimiters` is zero, then this function always returns
/// zero:
///
/// ```rust,ignore
/// use std::io::Cursor;
///
/// let mut reader = Cursor::new(&quot;a\n&quot;);
/// let i = forwards_thru_file(&amp;mut reader, 0, b&#39;\n&#39;).unwrap();
/// assert_eq!(i, 0);
/// ```
///
/// If there are fewer than `num_delimiters` instances of `delimiter`
/// in the reader, then this function returns the total number of
/// bytes read:
///
/// ```rust,ignore
/// use std::io::Cursor;
///
/// let mut reader = Cursor::new(&quot;a\n&quot;);
/// let i = forwards_thru_file(&amp;mut reader, 2, b&#39;\n&#39;).unwrap();
/// assert_eq!(i, 2);
/// ```
</span><span class="kw">fn </span>forwards_thru_file&lt;R&gt;(
    reader: <span class="kw-2">&amp;mut </span>R,
    num_delimiters: u64,
    delimiter: u8,
) -&gt; std::io::Result&lt;usize&gt;
<span class="kw">where
    </span>R: Read,
{
    <span class="kw">let </span><span class="kw-2">mut </span>reader = BufReader::new(reader);

    <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[];
    <span class="kw">let </span><span class="kw-2">mut </span>total = <span class="number">0</span>;
    <span class="kw">for _ in </span><span class="number">0</span>..num_delimiters {
        <span class="kw">match </span>reader.read_until(delimiter, <span class="kw-2">&amp;mut </span>buf) {
            <span class="prelude-val">Ok</span>(<span class="number">0</span>) =&gt; {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(total);
            }
            <span class="prelude-val">Ok</span>(n) =&gt; {
                total += n;
                buf.clear();
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(e) =&gt; {
                <span class="kw">return </span><span class="prelude-val">Err</span>(e);
            }
        }
    }
    <span class="prelude-val">Ok</span>(total)
}

<span class="doccomment">/// Iterate over bytes in the file, in reverse, until we find the
/// `num_delimiters` instance of `delimiter`. The `file` is left seek&#39;d to the
/// position just after that delimiter.
</span><span class="kw">fn </span>backwards_thru_file(file: <span class="kw-2">&amp;mut </span>File, num_delimiters: u64, delimiter: u8) {
    <span class="comment">// This variable counts the number of delimiters found in the file
    // so far (reading from the end of the file toward the beginning).
    </span><span class="kw">let </span><span class="kw-2">mut </span>counter = <span class="number">0</span>;

    <span class="kw">for </span>(block_idx, slice) <span class="kw">in </span>ReverseChunks::new(file).enumerate() {
        <span class="comment">// Iterate over each byte in the slice in reverse order.
        </span><span class="kw">let </span><span class="kw-2">mut </span>iter = slice.iter().enumerate().rev();

        <span class="comment">// Ignore a trailing newline in the last block, if there is one.
        </span><span class="kw">if </span>block_idx == <span class="number">0 </span>{
            <span class="kw">if let </span><span class="prelude-val">Some</span>(c) = slice.last() {
                <span class="kw">if </span><span class="kw-2">*</span>c == delimiter {
                    iter.next();
                }
            }
        }

        <span class="comment">// For each byte, increment the count of the number of
        // delimiters found. If we have found more than the specified
        // number of delimiters, terminate the search and seek to the
        // appropriate location in the file.
        </span><span class="kw">for </span>(i, ch) <span class="kw">in </span>iter {
            <span class="kw">if </span><span class="kw-2">*</span>ch == delimiter {
                counter += <span class="number">1</span>;
                <span class="kw">if </span>counter &gt;= num_delimiters {
                    <span class="comment">// After each iteration of the outer loop, the
                    // cursor in the file is at the *beginning* of the
                    // block, so seeking forward by `i + 1` bytes puts
                    // us right after the found delimiter.
                    </span>file.seek(SeekFrom::Current((i + <span class="number">1</span>) <span class="kw">as </span>i64)).unwrap();
                    <span class="kw">return</span>;
                }
            }
        }
    }
}

<span class="doccomment">/// When tail&#39;ing a file, we do not need to read the whole file from start to
/// finish just to find the last n lines or bytes. Instead, we can seek to the
/// end of the file, and then read the file &quot;backwards&quot; in blocks of size
/// `BLOCK_SIZE` until we find the location of the first line/byte. This ends up
/// being a nice performance win for very large files.
</span><span class="kw">fn </span>bounded_tail(file: <span class="kw-2">&amp;mut </span>File, settings: <span class="kw-2">&amp;</span>Settings) {
    <span class="macro">debug_assert!</span>(!settings.presume_input_pipe);

    <span class="comment">// Find the position in the file to start printing from.
    </span><span class="kw">match </span><span class="kw-2">&amp;</span>settings.mode {
        FilterMode::Lines(Signum::Negative(count), delimiter) =&gt; {
            backwards_thru_file(file, <span class="kw-2">*</span>count, <span class="kw-2">*</span>delimiter);
        }
        FilterMode::Lines(Signum::Positive(count), delimiter) <span class="kw">if </span>count &gt; <span class="kw-2">&amp;</span><span class="number">1 </span>=&gt; {
            <span class="kw">let </span>i = forwards_thru_file(file, <span class="kw-2">*</span>count - <span class="number">1</span>, <span class="kw-2">*</span>delimiter).unwrap();
            file.seek(SeekFrom::Start(i <span class="kw">as </span>u64)).unwrap();
        }
        FilterMode::Lines(Signum::MinusZero, <span class="kw">_</span>) =&gt; {
            <span class="kw">return</span>;
        }
        FilterMode::Bytes(Signum::Negative(count)) =&gt; {
            <span class="kw">let </span>len = file.seek(SeekFrom::End(<span class="number">0</span>)).unwrap();
            file.seek(SeekFrom::End(-((<span class="kw-2">*</span>count).min(len) <span class="kw">as </span>i64)))
                .unwrap();
        }
        FilterMode::Bytes(Signum::Positive(count)) <span class="kw">if </span>count &gt; <span class="kw-2">&amp;</span><span class="number">1 </span>=&gt; {
            <span class="comment">// GNU `tail` seems to index bytes and lines starting at 1, not
            // at 0. It seems to treat `+0` and `+1` as the same thing.
            </span>file.seek(SeekFrom::Start(<span class="kw-2">*</span>count - <span class="number">1</span>)).unwrap();
        }
        FilterMode::Bytes(Signum::MinusZero) =&gt; {
            <span class="kw">return</span>;
        }
        <span class="kw">_ </span>=&gt; {}
    }

    <span class="comment">// Print the target section of the file.
    </span><span class="kw">let </span>stdout = stdout();
    <span class="kw">let </span><span class="kw-2">mut </span>stdout = stdout.lock();
    std::io::copy(file, <span class="kw-2">&amp;mut </span>stdout).unwrap();
}

<span class="kw">fn </span>unbounded_tail&lt;T: Read&gt;(reader: <span class="kw-2">&amp;mut </span>BufReader&lt;T&gt;, settings: <span class="kw-2">&amp;</span>Settings) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>stdout = stdout();
    <span class="kw">let </span><span class="kw-2">mut </span>writer = BufWriter::new(stdout.lock());
    <span class="kw">match </span><span class="kw-2">&amp;</span>settings.mode {
        FilterMode::Lines(Signum::Negative(count), sep) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>chunks = chunks::LinesChunkBuffer::new(<span class="kw-2">*</span>sep, <span class="kw-2">*</span>count);
            chunks.fill(reader)<span class="question-mark">?</span>;
            chunks.print(<span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
        }
        FilterMode::Lines(Signum::PlusZero | Signum::Positive(<span class="number">1</span>), <span class="kw">_</span>) =&gt; {
            io::copy(reader, <span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
        }
        FilterMode::Lines(Signum::Positive(count), sep) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>num_skip = <span class="kw-2">*</span>count - <span class="number">1</span>;
            <span class="kw">let </span><span class="kw-2">mut </span>chunk = chunks::LinesChunk::new(<span class="kw-2">*</span>sep);
            <span class="kw">while </span>chunk.fill(reader)<span class="question-mark">?</span>.is_some() {
                <span class="kw">let </span>lines = chunk.get_lines() <span class="kw">as </span>u64;
                <span class="kw">if </span>lines &lt; num_skip {
                    num_skip -= lines;
                } <span class="kw">else </span>{
                    <span class="kw">break</span>;
                }
            }
            <span class="kw">if </span>chunk.has_data() {
                chunk.print_lines(<span class="kw-2">&amp;mut </span>writer, num_skip <span class="kw">as </span>usize)<span class="question-mark">?</span>;
                io::copy(reader, <span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
            }
        }
        FilterMode::Bytes(Signum::Negative(count)) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>chunks = chunks::BytesChunkBuffer::new(<span class="kw-2">*</span>count);
            chunks.fill(reader)<span class="question-mark">?</span>;
            chunks.print(<span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
        }
        FilterMode::Bytes(Signum::PlusZero | Signum::Positive(<span class="number">1</span>)) =&gt; {
            io::copy(reader, <span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
        }
        FilterMode::Bytes(Signum::Positive(count)) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>num_skip = <span class="kw-2">*</span>count - <span class="number">1</span>;
            <span class="kw">let </span><span class="kw-2">mut </span>chunk = chunks::BytesChunk::new();
            <span class="kw">loop </span>{
                <span class="kw">if let </span><span class="prelude-val">Some</span>(bytes) = chunk.fill(reader)<span class="question-mark">? </span>{
                    <span class="kw">let </span>bytes: u64 = bytes <span class="kw">as </span>u64;
                    <span class="kw">match </span>bytes.cmp(<span class="kw-2">&amp;</span>num_skip) {
                        Ordering::Less =&gt; num_skip -= bytes,
                        Ordering::Equal =&gt; {
                            <span class="kw">break</span>;
                        }
                        Ordering::Greater =&gt; {
                            writer.write_all(chunk.get_buffer_with(num_skip <span class="kw">as </span>usize))<span class="question-mark">?</span>;
                            <span class="kw">break</span>;
                        }
                    }
                } <span class="kw">else </span>{
                    <span class="kw">return </span><span class="prelude-val">Ok</span>(());
                }
            }

            io::copy(reader, <span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
        }
        <span class="kw">_ </span>=&gt; {}
    }
    <span class="prelude-val">Ok</span>(())
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>tests {

    <span class="kw">use </span><span class="kw">crate</span>::forwards_thru_file;
    <span class="kw">use </span>std::io::Cursor;

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_forwards_thru_file_zero() {
        <span class="kw">let </span><span class="kw-2">mut </span>reader = Cursor::new(<span class="string">&quot;a\n&quot;</span>);
        <span class="kw">let </span>i = forwards_thru_file(<span class="kw-2">&amp;mut </span>reader, <span class="number">0</span>, <span class="string">b&#39;\n&#39;</span>).unwrap();
        <span class="macro">assert_eq!</span>(i, <span class="number">0</span>);
    }

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_forwards_thru_file_basic() {
        <span class="comment">//                   01 23 45 67 89
        </span><span class="kw">let </span><span class="kw-2">mut </span>reader = Cursor::new(<span class="string">&quot;a\nb\nc\nd\ne\n&quot;</span>);
        <span class="kw">let </span>i = forwards_thru_file(<span class="kw-2">&amp;mut </span>reader, <span class="number">2</span>, <span class="string">b&#39;\n&#39;</span>).unwrap();
        <span class="macro">assert_eq!</span>(i, <span class="number">4</span>);
    }

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_forwards_thru_file_past_end() {
        <span class="kw">let </span><span class="kw-2">mut </span>reader = Cursor::new(<span class="string">&quot;x\n&quot;</span>);
        <span class="kw">let </span>i = forwards_thru_file(<span class="kw-2">&amp;mut </span>reader, <span class="number">2</span>, <span class="string">b&#39;\n&#39;</span>).unwrap();
        <span class="macro">assert_eq!</span>(i, <span class="number">2</span>);
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="uu_tail" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>